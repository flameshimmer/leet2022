class Solution {
private: 
    void dfs(string& beginWord, string& curWord, vector<string> &result, vector<vector<string>>& results, unordered_map<string, int>& levelMap) {
        if(curWord == beginWord) {
            reverse(result.begin(), result.end()); 
            results.push_back(result); 
            reverse(result.begin(), result.end()); 
            return; 
        }
         int level = levelMap[curWord]; 

         for(int i = 0; i< curWord.size();i++) {
            char backup = curWord[i]; 
            for(char c = 'a'; c <= 'z'; c++) {
                curWord[i] = c; 
                if(levelMap.find(curWord) != levelMap.end() 
                  && levelMap[curWord] + 1 == level) {
                    result.push_back(curWord); 
                    dfs(beginWord, curWord, result, results, levelMap); 
                    result.pop_back(); 
                }
            }
             curWord[i] = backup; 
         }
    }
public:
    vector<vector<string>> findLadders(string beginWord, string endWord, 
                                       vector<string> &wordList)
    {
        unordered_set<string> set(wordList.begin(), wordList.end()); 
        set.erase(beginWord); 

        queue<string> q;
        q.push({beginWord});
     
        unordered_map<string, int> levelMap;
        levelMap[beginWord] = 1; 


        while(!q.empty()) {
            string top = q.front(); 
            int level = levelMap[top]; 
            q.pop(); 

            if(top == endWord) break; 
            
            for(int i = 0; i < beginWord.size();i++) {
                char backup = top[i]; 
                for(char c = 'a'; c <= 'z'; c++) {
                    top[i] = c;
                    if(set.find(top) != set.end()) {
                        q.push(top); 
                        set.erase(top); 
                        levelMap[top] = level + 1;
                    }
                }
                top[i] = backup; 
            }
        }

        vector<vector<string>> results;
        if(levelMap.find(endWord) != levelMap.end()) {
            vector<string> result; 
            result.push_back(endWord); 
            dfs(beginWord, endWord, result, results, levelMap); 
        }
        return results; 
    }
};