
//vector<vector<int>> test = Now, three pruning steps:
//If the total number of characters in the board is less than the number of
//characters in word, then you can obviously return false; immediately.
//Basically, this is when word wouldn't fit in the board at all.
//For every character in word, that character must appear in board the same
//number of times or greater. Basically, the number of occurrences of any
//character c in board must be >= the number of occurrences of c in word.
//Adding these two pruning methods reduced my runtime from around 380ms (the
//original non-pruned program) to 45ms.
//Not so well-known (I think)
//Consider word = 'aaaaaaaaaab' and let board have all a except for one b in the
//lower-right corner. The problem is that when we try finding word from each
//starting point, we will find a lot of ways to construct aaaaaaaaaa each time,
//but we will never find that last b until our starting point is close the
//lower-right corner. For these cases, the non-pruned algorithm will be
//significantly slower.
//We can partially optimize these sorts of test cases as follows: find the
//longest prefix and suffix in word that are each made up of the same character.
//For example, if word = 'aaaabccc', the longest prefix and suffix are length 4
//and 3 respectively. If the longest prefix is longer than the longest suffix,
//then reverse the string. This makes it so that word having a very long prefix
//is a lot less likely. But in cases where the longest prefix/suffix have very
//close lengths, this won't really help. But for the LeetCode test data, this
//seems to generate a large speedup; I was able to get 0ms runtime when I
//submitted the following solution:;