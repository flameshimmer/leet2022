{"title":"382. Linked List Random Node","description":"Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen.\n\nImplement the Solution class:\n\nSolution(ListNode head) Initializes the object with the head of the singly-linked list head.\nint getRandom() Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be chosen.\n\n \n\nExample 1:\n\nInput\n[\"Solution\", \"getRandom\", \"getRandom\", \"getRandom\", \"getRandom\", \"getRandom\"]\n[[[1, 2, 3]], [], [], [], [], []]\nOutput\n[null, 1, 3, 2, 2, 3]\n\nExplanation\nSolution solution = new Solution([1, 2, 3]);\nsolution.getRandom(); // return 1\nsolution.getRandom(); // return 3\nsolution.getRandom(); // return 2\nsolution.getRandom(); // return 2\nsolution.getRandom(); // return 3\n// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.\n\n\n \n\nConstraints:\n\nThe number of nodes in the linked list will be in the range [1, 104].\n-104 <= Node.val <= 104\nAt most 104 calls will be made to getRandom.\n\n \n\nFollow up:\n\nWhat if the linked list is extremely large and its length is unknown to you?\nCould you solve this efficiently without using extra space?","functionSig":"1\n/**\n2\n * Definition for singly-linked list.\n3\n * struct ListNode {\n4\n *     int val;\n5\n *     ListNode *next;\n6\n *     ListNode() : val(0), next(nullptr) {}\n7\n *     ListNode(int x) : val(x), next(nullptr) {}\n8\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n9\n * };\n10\n */\n11\nclass Solution {\n12\npublic:\n13\n    Solution(ListNode* head) {\n14\n        \n15\n    }\n16\n    \n17\n    int getRandom() {\n18\n        \n19\n    }\n20\n};\n21\n​\n22\n/**\n23\n * Your Solution object will be instantiated and called as such:\n24\n * Solution* obj = new Solution(head);\n25\n * int param_1 = obj->getRandom();\n26\n */"}
