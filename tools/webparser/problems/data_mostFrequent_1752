{"title":"251. Flatten 2D Vector","description":"Design an iterator to flatten a 2D vector. It should support the next and hasNext operations.\n\nImplement the Vector2D class:\n\nVector2D(int[][] vec) initializes the object with the 2D vector vec.\nnext() returns the next element from the 2D vector and moves the pointer one step forward. You may assume that all the calls to next are valid.\nhasNext() returns true if there are still some elements in the vector, and false otherwise.\n\n \n\nExample 1:\n\nInput\n[\"Vector2D\", \"next\", \"next\", \"next\", \"hasNext\", \"hasNext\", \"next\", \"hasNext\"]\n[[[[1, 2], [3], [4]]], [], [], [], [], [], [], []]\nOutput\n[null, 1, 2, 3, true, true, 4, false]\n\nExplanation\nVector2D vector2D = new Vector2D([[1, 2], [3], [4]]);\nvector2D.next();    // return 1\nvector2D.next();    // return 2\nvector2D.next();    // return 3\nvector2D.hasNext(); // return True\nvector2D.hasNext(); // return True\nvector2D.next();    // return 4\nvector2D.hasNext(); // return False\n\n\n \n\nConstraints:\n\n0 <= vec.length <= 200\n0 <= vec[i].length <= 500\n-500 <= vec[i][j] <= 500\nAt most 105 calls will be made to next and hasNext.\n\n \n\nFollow up: As an added challenge, try to code it using only iterators in C++ or iterators in Java.","functionSig":"1\nclass Vector2D {\n2\npublic:\n3\n    Vector2D(vector<vector<int>>& vec) {\n4\n        \n5\n    }\n6\n    \n7\n    int next() {\n8\n        \n9\n    }\n10\n    \n11\n    bool hasNext() {\n12\n        \n13\n    }\n14\n};\n15\n​\n16\n/**\n17\n * Your Vector2D object will be instantiated and called as such:\n18\n * Vector2D* obj = new Vector2D(vec);\n19\n * int param_1 = obj->next();\n20\n * bool param_2 = obj->hasNext();\n21\n */"}
