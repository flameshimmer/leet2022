{"title":"2181. Merge Nodes in Between Zeros","description":"You are given the head of a linked list, which contains a series of integers separated by 0's. The beginning and end of the linked list will have Node.val == 0.\n\nFor every two consecutive 0's, merge all the nodes lying in between them into a single node whose value is the sum of all the merged nodes. The modified list should not contain any 0's.\n\nReturn the head of the modified linked list.\n\n \n\nExample 1:\n\nInput: head = [0,3,1,0,4,5,2,0]\nOutput: [4,11]\nExplanation: \nThe above figure represents the given linked list. The modified list contains\n- The sum of the nodes marked in green: 3 + 1 = 4.\n- The sum of the nodes marked in red: 4 + 5 + 2 = 11.\n\n\nExample 2:\n\nInput: head = [0,1,0,3,0,2,2,0]\nOutput: [1,3,4]\nExplanation: \nThe above figure represents the given linked list. The modified list contains\n- The sum of the nodes marked in green: 1 = 1.\n- The sum of the nodes marked in red: 3 = 3.\n- The sum of the nodes marked in yellow: 2 + 2 = 4.\n\n\n \n\nConstraints:\n\nThe number of nodes in the list is in the range [3, 2 * 105].\n0 <= Node.val <= 1000\nThere are no two consecutive nodes with Node.val == 0.\nThe beginning and end of the linked list have Node.val == 0.","functionSig":"1\n/**\n2\n * Definition for singly-linked list.\n3\n * struct ListNode {\n4\n *     int val;\n5\n *     ListNode *next;\n6\n *     ListNode() : val(0), next(nullptr) {}\n7\n *     ListNode(int x) : val(x), next(nullptr) {}\n8\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n9\n * };\n10\n */\n11\nclass Solution {\n12\npublic:\n13\n    ListNode* mergeNodes(ListNode* head) {\n14\n        \n15\n    }\n16\n};"}
