{"title":"1286. Iterator for Combination","description":"Design the CombinationIterator class:\n\nCombinationIterator(string characters, int combinationLength) Initializes the object with a string characters of sorted distinct lowercase English letters and a number combinationLength as arguments.\nnext() Returns the next combination of length combinationLength in lexicographical order.\nhasNext() Returns true if and only if there exists a next combination.\n\n \n\nExample 1:\n\nInput\n[\"CombinationIterator\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[\"abc\", 2], [], [], [], [], [], []]\nOutput\n[null, \"ab\", true, \"ac\", true, \"bc\", false]\n\nExplanation\nCombinationIterator itr = new CombinationIterator(\"abc\", 2);\nitr.next();    // return \"ab\"\nitr.hasNext(); // return True\nitr.next();    // return \"ac\"\nitr.hasNext(); // return True\nitr.next();    // return \"bc\"\nitr.hasNext(); // return False\n\n\n \n\nConstraints:\n\n1 <= combinationLength <= characters.length <= 15\nAll the characters of characters are unique.\nAt most 104 calls will be made to next and hasNext.\nIt is guaranteed that all calls of the function next are valid.","functionSig":"1\nclass CombinationIterator {\n2\npublic:\n3\n    CombinationIterator(string characters, int combinationLength) {\n4\n        \n5\n    }\n6\n    \n7\n    string next() {\n8\n        \n9\n    }\n10\n    \n11\n    bool hasNext() {\n12\n        \n13\n    }\n14\n};\n15\n​\n16\n/**\n17\n * Your CombinationIterator object will be instantiated and called as such:\n18\n * CombinationIterator* obj = new CombinationIterator(characters, combinationLength);\n19\n * string param_1 = obj->next();\n20\n * bool param_2 = obj->hasNext();\n21\n */"}
