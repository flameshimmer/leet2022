{"title":"1756. Design Most Recently Used Queue","description":"Design a queue-like data structure that moves the most recently used element to the end of the queue.\n\nImplement the MRUQueue class:\n\nMRUQueue(int n) constructs the MRUQueue with n elements: [1,2,3,...,n].\nint fetch(int k) moves the kth element (1-indexed) to the end of the queue and returns it.\n\n \n\nExample 1:\n\nInput:\n[\"MRUQueue\", \"fetch\", \"fetch\", \"fetch\", \"fetch\"]\n[[8], [3], [5], [2], [8]]\nOutput:\n[null, 3, 6, 2, 2]\n\nExplanation:\nMRUQueue mRUQueue = new MRUQueue(8); // Initializes the queue to [1,2,3,4,5,6,7,8].\nmRUQueue.fetch(3); // Moves the 3rd element (3) to the end of the queue to become [1,2,4,5,6,7,8,3] and returns it.\nmRUQueue.fetch(5); // Moves the 5th element (6) to the end of the queue to become [1,2,4,5,7,8,3,6] and returns it.\nmRUQueue.fetch(2); // Moves the 2nd element (2) to the end of the queue to become [1,4,5,7,8,3,6,2] and returns it.\nmRUQueue.fetch(8); // The 8th element (2) is already at the end of the queue so just return it.\n\n\n \n\nConstraints:\n\n1 <= n <= 2000\n1 <= k <= n\nAt most 2000 calls will be made to fetch.\n\n \n\nFollow up: Finding an O(n) algorithm per fetch is a bit easy. Can you find an algorithm with a better complexity for each fetch call?","functionSig":"1\nclass MRUQueue {\n2\npublic:\n3\n    MRUQueue(int n) {\n4\n        \n5\n    }\n6\n    \n7\n    int fetch(int k) {\n8\n        \n9\n    }\n10\n};\n11\n​\n12\n/**\n13\n * Your MRUQueue object will be instantiated and called as such:\n14\n * MRUQueue* obj = new MRUQueue(n);\n15\n * int param_1 = obj->fetch(k);\n16\n */"}
